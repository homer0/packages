import * as path from 'path';
import { envUtils, type EnvUtils } from '@homer0/env-utils';
import { get, set, copy, remove, merge } from '@homer0/object-utils';
import { pathUtils, type PathUtils } from '@homer0/path-utils';
import { rootFile, type RootFile } from '@homer0/root-file';
import { providerCreator, injectHelper } from '@homer0/jimple';
/**
 * The type of function a configuration file can export.
 */
export type SimpleConfigFileModuleFn<T = unknown> = (config: unknown) => T | Promise<T>;
/**
 * The contents of a configuration file.
 */
export type SimpleConfigFileModule<T = unknown> =
  | {
      default: T | SimpleConfigFileModuleFn<T>;
    }
  | T
  | SimpleConfigFileModuleFn<T>;

/**
 * The dictionary of dependencies that need to be injected in {@link SimpleConfig}.
 */
type SimpleConfigInjectOptions = {
  /**
   * The service that reads the env variables, to determine which settings to use.
   */
  envUtils: EnvUtils;
  /**
   * The service that generates paths relatives to the project root, necessary for the
   * `rootFile` service.
   */
  pathUtils: PathUtils;
  /**
   * The service to load the configuration file, from a path relative to the project root.
   */
  rootFile: RootFile;
};
/**
 * The inject helper to resolve the dependencies.
 */
const deps = injectHelper<SimpleConfigInjectOptions>();
/**
 * The options for the service constructor.
 */
export type SimpleConfigOptions = {
  /**
   * A dictionary with the dependency injections for the service. If one or more are not
   * provided, the service will create new instances.
   */
  inject?: Partial<SimpleConfigInjectOptions>;
  /**
   * The name of the configurations. This is used in the default name of the environment
   * variable, and the default format for the config files.
   *
   * @default 'app'
   */
  name?: string;
  /**
   * The default configuration. For small projects, without a lot of customization, this
   * should be enough to get started.
   *
   * @default
   */
  defaultConfig?: unknown;
  /**
   * The name of the default configuration. The name of a configuration allows you to
   * reference it from another configurations that extends it, or to use it to tell the
   * service to which configuration you want to switch to.
   *
   * @default 'default'
   */
  defaultConfigName?: string;
  /**
   * The name of the configuration file that could load the default configuration. This is
   * used in a case where you don't have a default configuration, and want to use
   * {@link SimpleConfig#load} to load it.
   * The default value is created using `name`, plus `.config.js`.
   *
   * @default 'app.config.js'
   */
  defaultConfigFilename?: string;
  /**
   * The name of the environment variable the service will look for in
   * {@link SimpleConfig.loadFromEnv}.
   * The default value is created using the upper case version of `name`, plus `_CONFIG`.
   *
   * @default 'APP_CONFIG'
   */
  envVarName?: string;
  /**
   * The path to the directory where the configuration files are located, relative to the
   * project root.
   * The default value is generated by using the `name` option, `config/[name]`.
   *
   * @default 'config/app'
   */
  path?: string;
  /**
   * The format for the name of other configuration files. It must include a `[name]`
   * placeholder, that will be replaced with the configuration name that the service is
   * trying to load.
   * The default value is created using the `name` option, and adding `.[name].config.js`
   * as suffix.
   *
   * @default 'app.[name].config.js'
   */
  filenameFormat?: string;
  /**
   * Whether or not the implementation can switch configurations by using the
   * {@link SimpleConfig.switch} method.
   *
   * @default false
   */
  allowConfigSwitch?: boolean;
  /**
   * Whether or not, when a new configuration is loaded, the service should check for the
   * `allowConfigSwitch` setting, and if exists, update the service with its value. This
   * means that `allowConfigSwitch` can be enabled in the constructor, and disabled by a
   * configuration that was loaded later.
   *
   * @default true
   */
  allowConfigSwitchSetting?: boolean;
};
/**
 * This is a service to manage configurations. It takes care of loading, activating,
 * switching, and merging configuration files.
 */
export class SimpleConfig {
  /**
   * The service customization options.
   */
  protected options: Required<Omit<SimpleConfigOptions, 'inject' | 'defaultConfig'>>;
  /**
   * A dictionary with the multiple configurations the service manages.
   */
  protected configs: Record<string, unknown> = {};
  /**
   * The name of the active configuration.
   */
  protected activeConfigName: string;
  /**
   * The service that checks the env variables.
   */
  protected envUtils: EnvUtils;
  /**
   * The service that imports a file relative to the root of the project.
   */
  protected rootFile: RootFile;
  constructor({
    inject = {},
    name = 'app',
    defaultConfig = {},
    defaultConfigName = 'default',
    allowConfigSwitch = false,
    allowConfigSwitchSetting = true,
    envVarName,
    path: configsPath,
    defaultConfigFilename,
    filenameFormat,
  }: SimpleConfigOptions = {}) {
    this.envUtils = deps.get(inject, 'envUtils', () => envUtils());
    const usePathUtils = deps.get(inject, 'pathUtils', () => pathUtils());
    this.rootFile = deps.get(inject, 'rootFile', () =>
      rootFile({
        inject: {
          pathUtils: usePathUtils,
        },
      }),
    );
    this.options = {
      name,
      defaultConfigName,
      defaultConfigFilename: defaultConfigFilename || `${name}.config.js`,
      envVarName: envVarName || `${name.toUpperCase()}_CONFIG`,
      path: configsPath || path.join('config', name),
      filenameFormat: filenameFormat || `${name}.[name].config.js`,
      allowConfigSwitch,
      allowConfigSwitchSetting,
    };
    this.configs[defaultConfigName] = defaultConfig;
    this.activeConfigName = this.options.defaultConfigName;
  }
  getConfig<T = unknown>(): T;
  getConfig<T = unknown>(name: string): T | undefined;
  /**
   * Gets a configuration settings. If no name is specified, it will return the settings
   * of the active configuration.
   *
   * @param name  The name of the configuration.
   * @returns When a name is specified, if the configuration doesn't exist, it will
   *          return `undefined`.
   * @template T  The type of the configuration, for the return value.
   */
  getConfig<T = unknown>(name: string = ''): T | undefined {
    const config = this.getConfigDict<T>(name);
    if (!config) return undefined;
    return copy(config);
  }
  /**
   * Overwrites all the settings for a configuration. If the name is not specified, it
   * will overwrite the active configuration.
   * This could also be used to create a new configuration, by just sending a name for one
   * that doesn't exist in the service.
   *
   * @param config       The new configuration settings.
   * @param name         The name of the configuration.
   * @param mergeConfig  Whether or not to merge the new settings with the existing
   *                     ones.
   * @returns The updated configuration.
   * @template T  The type of the configuration, for the return value.
   */
  setConfig<T = unknown>(
    config: unknown,
    name: string = '',
    mergeConfig: boolean = true,
  ) {
    const key = name || this.activeConfigName;
    const newConfig = mergeConfig
      ? merge(this.getConfigDict<T>(key) || {}, config)
      : config;
    this.configs[key] = newConfig;
    return this.getConfig<T>(key);
  }
  /**
   * Gets a setting or a group of them from the active configuration.
   *
   * @param setting  A setting path or a list of them.
   * @param asArray  When `setting` is an Array, if this is `true`,
   *                 instead of returning a dictionary, it will return an array of
   *                 settings.
   * @template T  The type of the setting(s), for the return value.
   * @example
   *
   * <caption>Get a single setting</caption>
   *
   *   const value = config.get('some-setting');
   *
   * @example
   *
   * <caption>Get multiple settings</caption>
   *
   *   const { settingOne, settingTwo } = config.get(['settingOne', 'settingTwo']);
   *
   * @example
   *
   * <caption>Get multiple settings as an array</caption>
   *
   *   const [settingOne, settingTwo] = config.get(['settingOne', 'settingTwo'], true);
   *
   * @example
   *
   * <caption>Use paths</caption>
   *
   *   const subValue = config.get('settingOne.subSetting');
   *
   */
  get<T = unknown>(setting: string | string[], asArray: boolean = false): T {
    if (Array.isArray(setting)) {
      if (asArray) {
        return setting.map((key) => this.get(key)) as unknown as T;
      }

      const dict = setting.reduce<Record<string, unknown>>((acc, key) => {
        acc[key] = this.get(key);
        return acc;
      }, {});

      return dict as unknown as T;
    }

    if (setting === 'name') {
      return this.activeConfigName as unknown as T;
    }

    return get<T>({
      target: this.getConfig(),
      path: setting,
    })!;
  }
  /**
   * Sets the value of a setting or settings on the active configuration.
   * If both the current and the new value of a setting are objects, then instead of
   * overwriting it, the method will merge them.
   *
   * @param setting       The name of the setting to update, or a dictionary of
   *                      settings and their values.
   * @param value         The value of the setting. This is only used when `setting` is
   *                      a string.
   * @param mergeObjects  If both the current and the new value of a setting are
   *                      objects, then instead of overwriting it, the method will
   *                      merge them.
   * @throws If `setting` is not a dictionary, and `value` is `undefined`.
   * @example
   *
   * <caption>Set a single setting</caption>
   *
   *   config.set('some-setting', 'some-setting-value');
   *
   * @example
   *
   * <caption>Set multiple settings</caption>
   *
   *   config.set({
   *     settingOne: 'valueOne',
   *     settingTwo: 'valueTwo',
   *   });
   *
   */
  set(
    setting: string | Record<string, unknown>,
    value?: unknown,
    mergeObjects: boolean = true,
  ): void {
    if (typeof setting !== 'string') {
      Object.keys(setting).forEach((key) => {
        this.set(key, setting[key], mergeObjects);
      });

      return;
    }

    if (typeof value === 'undefined') {
      throw new Error('The value is required');
    }

    let newValue = value;
    if (mergeObjects) {
      const currentValue = this.get(setting);
      if (typeof value === 'object' && typeof currentValue !== 'undefined') {
        newValue = merge(currentValue, newValue);
      }
    }

    this.setConfig(
      set({
        target: {},
        path: setting,
        value: newValue,
      }),
    );
  }
  /**
   * Loads a configuration from a file, by importing it.
   *
   * @param name           The name of the configuration.
   * @param switchTo       If the service should switch to the new configuration after
   *                       loading it.
   * @param failWithError  If this is true and the file doesn't exist, it throw an
   *                       error.
   * @returns The settings of the loaded configuration.
   * @template T  The type of the configuration, for the return value.
   * @throws If the configuration file can't be loaded.
   */
  async loadFromFile<T = unknown>(
    name?: string,
    switchTo?: boolean,
    failWithError?: true,
  ): Promise<T>;
  async loadFromFile<T = unknown>(
    name?: string,
    switchTo?: boolean,
    failWithError?: false,
  ): Promise<T | undefined>;
  async loadFromFile<T = unknown>(
    name: string = '',
    switchTo: boolean = true,
    failWithError: boolean = true,
  ): Promise<T | undefined> {
    const {
      path: thisPath,
      filenameFormat,
      defaultConfigName,
      defaultConfigFilename,
    } = this.options;
    const [filename, newName] = name
      ? [filenameFormat.replace(/\[name\]/gi, name), name]
      : [defaultConfigFilename, defaultConfigName];
    const filepath = path.join(thisPath, filename);

    let config: T;
    try {
      let mod: SimpleConfigFileModule<T>;
      try {
        mod = await this.rootFile.import<SimpleConfigFileModule<T>>(filepath);
      } catch (error) {
        if (failWithError) {
          throw error;
        }

        return undefined;
      }
      let mainExport: T | SimpleConfigFileModuleFn<T>;
      if (mod && typeof mod === 'object' && 'default' in mod) {
        mainExport = mod.default;
      } else {
        mainExport = mod;
      }

      if (typeof mainExport === 'function') {
        const mainExportFn = mainExport as SimpleConfigFileModuleFn<T>;
        const mainExportValue = mainExportFn(this.getConfig());
        if (
          mainExportValue &&
          typeof mainExportValue === 'object' &&
          'then' in mainExportValue &&
          typeof mainExportValue.then === 'function'
        ) {
          config = await mainExportValue;
        } else {
          config = mainExportValue as T;
        }
      } else {
        config = mainExport;
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Could not load config from file: ${filepath} - ${message}`);
    }

    const extendsFrom =
      get<string>({
        target: config,
        path: 'extends',
      }) || defaultConfigName;

    let baseConfig = this.getConfigDict(extendsFrom);
    if (!baseConfig) {
      baseConfig = await this.loadFromFile(extendsFrom, false);
    }

    this.addConfig(newName, merge(baseConfig, config), switchTo);
    return this.getConfig(newName)!;
  }
  /**
   * Loads a new configuration.
   *
   * @param name      The configuration name.
   * @param config    The configuration settings.
   * @param switchTo  If the service should switch to the new configuration after
   *                  adding it.
   * @returns The settings of the new configuration.
   * @template T  The type of the configuration, for the return value.
   */
  async load<T = unknown>(
    name: string,
    config: unknown,
    switchTo: boolean = true,
  ): Promise<T> {
    const extendsFrom =
      get<string>({
        target: config,
        path: 'extends',
      }) || this.options.defaultConfigName;
    let baseConfig = this.getConfig(extendsFrom);
    if (!baseConfig) {
      baseConfig = await this.loadFromFile(extendsFrom, false);
    }

    this.addConfig(name, merge(baseConfig, config), switchTo);
    return this.getConfig(name)!;
  }
  /**
   * Checks if there's a configuration name specified on the environment variable (which
   * name was provided in the constructor), and if there is,
   * tries to load it from its file (by calling {@link SimpleConfig.loadFromFile}).
   *
   * @returns {Object} The loaded configuration or the current configuration if no name
   *                   was specified.
   * @template T  The type of the configuration, for the return value.
   */
  async loadFromEnv<T = unknown>(switchTo: boolean = true): Promise<T> {
    const envVar = this.envUtils.get(this.options.envVarName);
    if (!envVar) {
      return this.getConfig<T>()!;
    }

    return this.loadFromFile(envVar, switchTo);
  }
  /**
   * Switches to a different configuration. If the configuration is not registered, it
   * will try to load it from a file.
   *
   * @param name   The new of the configuration to switch to.
   * @param force  A way to force the service to switch, even if the
   *               `allowConfigSwitch` option was set to `false`.
   * @returns The new active configuration.
   * @template T  The type of the configuration, for the return value.
   * @throws {Error} If `force` is `false` and the `allowConfigSwitch` option is
   *                 `false`.
   */
  async switch<T = unknown>(name: string, force: boolean = false): Promise<T> {
    if (!this.options.allowConfigSwitch && !force) {
      throw new Error(
        `You can't switch the config to '${name}', the feature is disabled`,
      );
    }

    if (!this.configs[name]) {
      await this.loadFromFile(name);
    }

    this.activeConfigName = name;
    return this.getConfig<T>()!;
  }
  /**
   * Returns the customization options used to initialize the service.
   */
  getOptions(): SimpleConfig['options'] {
    return copy(this.options);
  }
  /**
   * Checks whether the service allows configurations to be switched.
   */
  canSwitchConfigs(): boolean {
    return this.options.allowConfigSwitch;
  }
  /**
   * Whenever the service returns a configuration, it returns a copy, so no mutation by
   * reference can happen. This method is internally used to access the real configuration
   * objects, in context in which there's no possibility of mutation. For example:
   * checking if a configuration exists, or using it as a base for a new one.
   *
   * @param name  The name of the configuration to get.
   * @template T  The type of the configuration, for the return value.
   */
  protected getConfigDict<T = unknown>(name: string): T | undefined {
    return this.configs[name || this.activeConfigName] as T | undefined;
  }
  /**
   * Adds a new configuration to the service. This is different from how
   * {@link SimpleConfig.setConfig} does it, as this method checks for the
   * `allowConfigSwitch` setting, if enabled, and also allows to automatically switch to
   * the new configuration.
   *
   * @param name      The name of the new configuration.
   * @param config    The configuration settings.
   * @param switchTo  Whether or not to switch it to the active configuration after
   *                  adding it.
   */
  protected addConfig(name: string, config: unknown, switchTo: boolean) {
    const newConfig = remove({
      target: config,
      path: 'extends',
    });

    if (this.options.allowConfigSwitchSetting) {
      const canSwitch = <boolean | undefined>get({
        target: newConfig,
        path: 'allowConfigSwitch',
      });

      if (typeof canSwitch === 'boolean') {
        this.options.allowConfigSwitch = canSwitch;
      }
    }

    this.configs[name] = newConfig;

    if (switchTo) {
      this.switch(name, true);
    }
  }
}
/**
 * Shorthand for `new SimpleConfig()`.
 *
 * @param args  The same parameters as the {@link SimpleConfig} constructor.
 * @returns A new instance of {@link SimpleConfig}.
 */
export const simpleConfig = (
  ...args: ConstructorParameters<typeof SimpleConfig>
): SimpleConfig => new SimpleConfig(...args);

/**
 * The options for the {@link SimpleConfig} Jimple's provider creator.
 */
export type SimpleConfigProviderOptions = Omit<SimpleConfigOptions, 'inject'> & {
  /**
   * The name that will be used to register the service.
   *
   * @default 'config'
   */
  serviceName?: string;
  /**
   * A dictionary with the name of the services to inject. If one or more are not
   * provided, the service will create new instances.
   */
  services?: {
    [key in keyof SimpleConfigInjectOptions]?: string;
  };
};
/**
 * A provider creator to register {@link SimpleConfig} in a Jimple container.
 */
export const simpleConfigProvider = providerCreator(
  ({ serviceName = 'config', ...rest }: SimpleConfigProviderOptions = {}) =>
    (container) => {
      container.set(serviceName, () => {
        const { services = {}, ...options } = rest;
        const inject = deps.resolve(
          ['envUtils', 'pathUtils', 'rootFile'],
          container,
          services,
        );

        return new SimpleConfig({ inject, ...options });
      });
    },
);
